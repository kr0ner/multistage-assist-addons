"""File watcher for cache files with polling fallback.

Watches cache files for changes and triggers reload when modified.
Polls for missing files that may appear later (e.g., generated by Multi-Stage Assist).
"""

import asyncio
import logging
import os
from pathlib import Path
from typing import Callable, Dict, List, Optional, Set

from watchdog.events import FileSystemEventHandler, FileModifiedEvent, FileCreatedEvent
from watchdog.observers import Observer

logger = logging.getLogger("reranker.file_watcher")


class CacheFileHandler(FileSystemEventHandler):
    """Handler for cache file change events."""

    def __init__(self, watched_files: Set[str], on_change: Callable[[str], None]):
        """
        Initialize handler.

        Args:
            watched_files: Set of absolute file paths to watch
            on_change: Callback when a watched file changes (receives file path)
        """
        super().__init__()
        self._watched_files = watched_files
        self._on_change = on_change

    def on_modified(self, event: FileModifiedEvent) -> None:
        """Handle file modification events."""
        if event.is_directory:
            return
        self._check_and_notify(event.src_path)

    def on_created(self, event: FileCreatedEvent) -> None:
        """Handle file creation events."""
        if event.is_directory:
            return
        self._check_and_notify(event.src_path)

    def _check_and_notify(self, path: str) -> None:
        """Check if path is watched and notify callback."""
        abs_path = os.path.abspath(path)
        if abs_path in self._watched_files:
            logger.info(f"Detected change in: {abs_path}")
            self._on_change(abs_path)


class CacheFileWatcher:
    """
    Watch cache files for changes with polling fallback.

    Features:
    - Uses watchdog for efficient OS-level file monitoring
    - Polls for missing files at configurable intervals
    - Debounces rapid changes to avoid multiple reloads
    - Thread-safe async interface
    """

    def __init__(
        self,
        file_paths: List[str],
        on_reload: Callable[[], None],
        poll_interval: float = 30.0,
        debounce_seconds: float = 2.0,
    ):
        """
        Initialize file watcher.

        Args:
            file_paths: List of file paths to watch
            on_reload: Callback to invoke when reload is needed
            poll_interval: Seconds between polls for missing files
            debounce_seconds: Minimum seconds between reloads
        """
        self._file_paths = [os.path.abspath(p) for p in file_paths]
        self._on_reload = on_reload
        self._poll_interval = poll_interval
        self._debounce_seconds = debounce_seconds

        self._observer: Optional[Observer] = None
        self._poll_task: Optional[asyncio.Task] = None
        self._running = False

        # Track file modification times for polling
        self._last_mtimes: Dict[str, float] = {}
        # Debounce tracking
        self._last_reload_time: float = 0
        self._pending_reload: bool = False
        self._debounce_task: Optional[asyncio.Task] = None

    async def start(self) -> None:
        """Start watching files and polling for missing ones."""
        if self._running:
            return

        self._running = True
        logger.info(f"Starting file watcher for: {self._file_paths}")

        # Initialize modification times for existing files
        for path in self._file_paths:
            if os.path.exists(path):
                self._last_mtimes[path] = os.path.getmtime(path)
                logger.debug(f"Tracking existing file: {path}")
            else:
                logger.info(f"File not found (will poll): {path}")

        # Start watchdog observer for existing directories
        self._start_observer()

        # Start polling task for missing files and fallback
        self._poll_task = asyncio.create_task(self._poll_loop())

    def _start_observer(self) -> None:
        """Start the watchdog observer."""
        try:
            # Get unique directories to watch
            dirs_to_watch: Set[str] = set()
            for path in self._file_paths:
                parent = os.path.dirname(path)
                if os.path.isdir(parent):
                    dirs_to_watch.add(parent)

            if not dirs_to_watch:
                logger.warning("No valid directories to watch")
                return

            # Create handler and observer
            handler = CacheFileHandler(
                watched_files=set(self._file_paths),
                on_change=self._on_file_change,
            )

            self._observer = Observer()
            for dir_path in dirs_to_watch:
                self._observer.schedule(handler, dir_path, recursive=False)
                logger.debug(f"Watching directory: {dir_path}")

            self._observer.start()
            logger.info("Watchdog observer started")

        except Exception as e:
            logger.warning(f"Failed to start watchdog observer: {e}")
            logger.info("Will rely on polling fallback")

    def _on_file_change(self, path: str) -> None:
        """Handle file change notification from watchdog."""
        # Schedule debounced reload in the async context
        asyncio.get_event_loop().call_soon_threadsafe(
            lambda: asyncio.create_task(self._schedule_reload(path))
        )

    async def _schedule_reload(self, changed_path: str) -> None:
        """Schedule a debounced reload."""
        import time

        now = time.time()
        time_since_last = now - self._last_reload_time

        if time_since_last < self._debounce_seconds:
            # Too soon, mark pending
            self._pending_reload = True
            logger.debug(f"Debouncing reload (changed: {changed_path})")

            # Schedule delayed reload if not already scheduled
            if self._debounce_task is None or self._debounce_task.done():
                delay = self._debounce_seconds - time_since_last
                self._debounce_task = asyncio.create_task(self._delayed_reload(delay))
        else:
            # Execute reload now
            await self._do_reload()

    async def _delayed_reload(self, delay: float) -> None:
        """Execute a delayed reload after debounce period."""
        await asyncio.sleep(delay)
        if self._pending_reload:
            await self._do_reload()

    async def _do_reload(self) -> None:
        """Execute the reload callback."""
        import time

        self._pending_reload = False
        self._last_reload_time = time.time()

        # Update modification times
        for path in self._file_paths:
            if os.path.exists(path):
                self._last_mtimes[path] = os.path.getmtime(path)

        logger.info("Triggering cache reload")
        try:
            self._on_reload()
        except Exception as e:
            logger.error(f"Reload callback failed: {e}")

    async def _poll_loop(self) -> None:
        """Polling loop for missing files and fallback detection."""
        while self._running:
            try:
                await asyncio.sleep(self._poll_interval)

                if not self._running:
                    break

                changed = False
                for path in self._file_paths:
                    if os.path.exists(path):
                        current_mtime = os.path.getmtime(path)
                        last_mtime = self._last_mtimes.get(path, 0)

                        if current_mtime > last_mtime:
                            if last_mtime == 0:
                                logger.info(f"File appeared: {path}")
                            else:
                                logger.info(f"File changed (poll): {path}")
                            changed = True

                if changed:
                    await self._schedule_reload("poll")

            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.warning(f"Poll loop error: {e}")

    async def stop(self) -> None:
        """Stop watching files."""
        if not self._running:
            return

        self._running = False
        logger.info("Stopping file watcher")

        # Stop polling task
        if self._poll_task:
            self._poll_task.cancel()
            try:
                await self._poll_task
            except asyncio.CancelledError:
                pass

        # Stop debounce task
        if self._debounce_task:
            self._debounce_task.cancel()
            try:
                await self._debounce_task
            except asyncio.CancelledError:
                pass

        # Stop watchdog observer
        if self._observer:
            self._observer.stop()
            self._observer.join(timeout=5)

        logger.info("File watcher stopped")
